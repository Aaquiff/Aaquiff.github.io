<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-05-06T01:42:48+05:30</updated><id>http://localhost:4000/feed.xml</id><title type="html">Aaquiff Ahnaff Rauf</title><subtitle></subtitle><entry><title type="html">Bare Metal Kubernetes Cluster</title><link href="http://localhost:4000/kubrnetes/2019/02/01/bare-metal-kubernetes-cluster.html" rel="alternate" type="text/html" title="Bare Metal Kubernetes Cluster" /><published>2019-02-01T00:50:05+05:30</published><updated>2019-02-01T00:50:05+05:30</updated><id>http://localhost:4000/kubrnetes/2019/02/01/bare-metal-kubernetes-cluster</id><content type="html" xml:base="http://localhost:4000/kubrnetes/2019/02/01/bare-metal-kubernetes-cluster.html">&lt;p&gt;Kubernetes is an open source project initiated by google to ease the pain of deploying, managing and scaling containerized applications. There exists many flavors of kubernetes clouds such as&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GKE (Google’s very own kubernetes engine)&lt;/li&gt;
  &lt;li&gt;AWS Eks&lt;/li&gt;
  &lt;li&gt;Openshift&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you are new to kubernetes and feel the need to experiment you could always try the single node solutions given below or utilize the free credit on GKE.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Minikube&lt;/li&gt;
  &lt;li&gt;Minishift&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;However if you are feeling a bit more adventurous and have some computing power to spare you could always bootstrap your own kubernetes cluster effortlessly. You would need two machines at-least for this and static IPs within the network to find them.&lt;/p&gt;

&lt;p&gt;In this single node setup one machine will be the master while the other a node. All nodes(including the master) requires some basic tools to create and join the cluster. Docker, kubelet, kubectl(optional). In addition to those the master will need kubeadm to administrate the cluster.&lt;/p&gt;

&lt;p&gt;If you are planning to access the cluster from a different machine (most probable scenario) you would need kubectl installed in that machine. kubectl is a kubernetes client application written in GO that could talk to the kubernetes API that we are going to setup in the master node.&lt;/p&gt;

&lt;h1 id=&quot;setting-up-the-master&quot;&gt;Setting up the master&lt;/h1&gt;

&lt;p&gt;SSH into the master machine and use the following commands to install the required tools.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-get update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; apt-transport-https
curl &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; https://download.docker.com/linux/ubuntu/gpg | &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-key add -
add-apt-repository &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;s2&quot;&gt;&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&quot;&lt;/span&gt;
apt update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qy&lt;/span&gt; docker-ce
curl &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;deb http://apt.kubernetes.io/ kubernetes-xenial main&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /etc/apt/sources.list.d/kubernetes.list
apt-get update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; kubeadm kubelet kubectl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Use &lt;strong&gt;KUBEADM&lt;/strong&gt; to initialise the cluster using the following command where **&lt;MASTER_IP&gt;** is the IP of the master 
machine that the nodes could find and –pod-network-cidr could be any range of IP addresses that the pods inside the clusters can be assigned to. This network range is isolated from the external network and only used for inter-cluster communication. However it should be noted that assigning the IP range as same as your network could cause problems.&lt;/MASTER_IP&gt;&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubeadm init &lt;span class=&quot;nt&quot;&gt;--apiserver-advertise-address&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;MASTER_IP&amp;gt; &lt;span class=&quot;nt&quot;&gt;--pod-network-cidr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;192.168.1.0/16
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After the command has run, you will find a command in the output that can be used by the worker nodes to join the cluster initialized by the master.&lt;/p&gt;

&lt;p&gt;In addition, you need to setup a CIDR for maintaining the internal network. You could find a few options if you skim through the kubernetes documentation. We chose to go with flannel which could be installed using the command given below.&lt;/p&gt;

&lt;h1 id=&quot;setting-up-the-worker-nodes&quot;&gt;Setting up the worker node(s)&lt;/h1&gt;

&lt;p&gt;This is fairly straight forward. Install the dependencies as before using the following commands and use the join command we got earlier.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This is fairly straight forward. Install the dependencies as before using the following commands and use the join command we got earlier.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt-get update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; apt-transport-https
curl &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; https://download.docker.com/linux/ubuntu/gpg | &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-key add -
add-apt-repository &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&quot;&lt;/span&gt;
apt update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-qy&lt;/span&gt; docker-ce
curl &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;deb http://apt.kubernetes.io/ kubernetes-xenial main&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /etc/apt/sources.list.d/kubernetes.list
apt-get update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; kubeadm kubelet kubectl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you’ve missed it or you want to join a new node to the cluster, use the following command to get a new token along with the join command.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;kubeadm token create &lt;span class=&quot;nt&quot;&gt;--print-join-command&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;give-it-a-go&quot;&gt;Give it a go!&lt;/h1&gt;

&lt;p&gt;With the kubernetes configuration we copied earlier from the master, we are now able to connect to the cluster and administrate it using the kubernetes API. To test the nodes in the cluster, use the following command.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get nodes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If all went well, you should see two nodes including the master and a worker node. You could always expand your cluster by adding new nodes to it by following the steps in the above section.&lt;/p&gt;</content><author><name></name></author><summary type="html">Kubernetes is an open source project initiated by google to ease the pain of deploying, managing and scaling containerized applications. There exists many flavors of kubernetes clouds such as</summary></entry><entry><title type="html">Cross-Site Request Forgery</title><link href="http://localhost:4000/csrf/2018/10/10/cross-site-request-forgery.html" rel="alternate" type="text/html" title="Cross-Site Request Forgery" /><published>2018-10-10T00:50:05+05:30</published><updated>2018-10-10T00:50:05+05:30</updated><id>http://localhost:4000/csrf/2018/10/10/cross-site-request-forgery</id><content type="html" xml:base="http://localhost:4000/csrf/2018/10/10/cross-site-request-forgery.html">&lt;h1 id=&quot;what-is-is-csrf&quot;&gt;What is is CSRF?&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Cross-Site Request Forgery(CSRF)&lt;/strong&gt; is a web browser based attack that tricks the user to execute operations on a 
different domain than that the current browsing domain. It is used to perform operations unknowingly to the user but could be used for theft of information as well. Imagine you are logged into Facebook and browsing a malicious website at the same time and the attacker knows the request format for a operation that could alter the users account and includes an ajax call in the malicious website that performs the state changing request to Facebook. The browser will send this request along with all cookies related to Facebook as well and hence will seem to be a legitimate request.&lt;/p&gt;

&lt;h1 id=&quot;protection&quot;&gt;Protection&lt;/h1&gt;

&lt;p&gt;To protect against CSRF, we need to prove that the request is coming from the form, that we have provided to the user. In order to do this validation we use a token that is embedded into the form page and subsequently sent with the post request to the server. Request(like AJAX) is  sent on form load to receive this token. A question arises here, couldn’t the malicious website do the same to get the token from the server? No! because of Same-Origin policy which defines that the request can only come from the same domain.&lt;/p&gt;

&lt;p&gt;There are two methods of implementing protection against CSRF and are explained below.&lt;/p&gt;

&lt;h2 id=&quot;synchronous-token-pattern&quot;&gt;Synchronous Token Pattern&lt;/h2&gt;

&lt;p&gt;In this method, the server generates a token for each session and stores it in a key value like store. The next time the form loads, it requests the token from the server to which the server responds and the browser embeds the token in the form. Subsequently, when the form is posted, the token is sent along with the form data. The server then validates the received token against the token in the server that maps to the session id to check if it is from the valid form.&lt;/p&gt;

&lt;p&gt;This can help avoid CSRF However when there are huge heap of connections open, the server needs to maintain these tokens and this would be problematic in terms of storage and performance. To avoid the need for the server to store tokens, an alternative pattern called Double Submit Cookie Pattern is used.&lt;/p&gt;

&lt;p&gt;Sample of a Java Web Application protected with Synchronous Token Pattern can be found &lt;a href=&quot;https://github.com/Aaquiff/csrf-synchronizer-token-pattern-example&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;double-submit-cookie-pattern&quot;&gt;Double Submit Cookie Pattern&lt;/h2&gt;

&lt;p&gt;This, instead of storing the token in the server, creates a cookie for the token in the browser. Now the browser has the CSRF token embedded in the form as well as a cookie containing the same CSRF token. When the data is posted to the server, the CSRF token in the cookie is sent along with the token in the form data.The server, then validates that both token values are equal to confirm that the request is coming from the legitimate site.&lt;/p&gt;

&lt;p&gt;Sample for a Java Web Application protected with Double Submit Cookie Pattern can be found &lt;a href=&quot;https://github.com/Aaquiff/csrf-double-submit-cookie-example&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">What is is CSRF?</summary></entry><entry><title type="html">Google Drive File Up-loader using OAuth2</title><link href="http://localhost:4000/googledrive/oauth2/2018/10/05/google-drive-file-uploader-using-oauth2.html" rel="alternate" type="text/html" title="Google Drive File Up-loader using OAuth2" /><published>2018-10-05T00:50:05+05:30</published><updated>2018-10-05T00:50:05+05:30</updated><id>http://localhost:4000/googledrive/oauth2/2018/10/05/google-drive-file-uploader-using-oauth2</id><content type="html" xml:base="http://localhost:4000/googledrive/oauth2/2018/10/05/google-drive-file-uploader-using-oauth2.html">&lt;p&gt;This article explains how to create an application that can be used to upload files to google drive using OAuth2 authorization framework and Google Drive API.&lt;/p&gt;

&lt;p&gt;The application could be found at this GitHub &lt;a href=&quot;https://github.com/Aaquiff/Demo-OAuth&quot;&gt;repository&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;flow-of-the-application&quot;&gt;Flow of the application&lt;/h1&gt;

&lt;p&gt;When you navigate to the application homepage, you will be greeted with the following page. As you can see there is an option to login with your google account.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-10-05-google-drive-file-uploader-using-oauth2/start.png&quot; alt=&quot;start.png&quot; title=&quot;start.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Clicking on the link will redirect you to the authorization page at google where you would authorize the application Demo-OAuth to access your google drive. If you have multiple google accounts linked in your browser you might get a prompt like below to choose the account you want to use.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-10-05-google-drive-file-uploader-using-oauth2/choose-account.png&quot; alt=&quot;choose-account.png&quot; title=&quot;choose-account.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once you choose an account you will be prompted with a screen to authorize Demo-OAuth application to access your google drive account.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-10-05-google-drive-file-uploader-using-oauth2/request-access-for-app.png&quot; alt=&quot;request-access-for-app.png&quot; title=&quot;request-access-for-app.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-10-05-google-drive-file-uploader-using-oauth2/email-confirmation1.png&quot; alt=&quot;email-confirmation1.png&quot; title=&quot;email-confirmation1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After you have carefully read about what this authorization will allow the app (or not), click allow to authorize the app. After doing so you will receive an email that notifies you that the app has been authorized. Your browser will also be redirected back to the application home page and you will be logged in with your google account. Your username will appear along with an option to log out.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-10-05-google-drive-file-uploader-using-oauth2/logged-in-as-aaquif.png&quot; alt=&quot;logged-in-as-aaquif.png&quot; title=&quot;logged-in-as-aaquif.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Click on the choose file button and select the file you want to upload to google drive.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-10-05-google-drive-file-uploader-using-oauth2/choose-file.png&quot; alt=&quot;choose-file.png&quot; title=&quot;choose-file.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The file chosen will be uploaded to Google Drive.&lt;/p&gt;

&lt;h1 id=&quot;implementation&quot;&gt;Implementation&lt;/h1&gt;

&lt;p&gt;The following sequence diagram sums up all the flows that happen during the authorization and file upload steps.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-10-05-google-drive-file-uploader-using-oauth2/authorization-flow.png&quot; alt=&quot;authorization-flow.png&quot; title=&quot;authorization-flow.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;User requests the index.html bu navigating to the root  of the application. He is presented with the UI and chooses to login with google. The web browser then posts to the /oauth2 endpoint which redirects the user to the google authorization flow appending the following information.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;scope – What do you want to authorize? In this case it is Google Drive and the Users Profile
https://www.googleapis.com/auth/drive&lt;/li&gt;
  &lt;li&gt;profile&lt;/li&gt;
  &lt;li&gt;access_type – setting this to offline allows the resource to be accessed when the user is offline.&lt;/li&gt;
  &lt;li&gt;state – Random value&lt;/li&gt;
  &lt;li&gt;redirect_url – URL to redirect  the user after the authorization flow&lt;/li&gt;
  &lt;li&gt;response_type – code, means that the authorization code will be used as the mechanism.&lt;/li&gt;
  &lt;li&gt;client_id – ID that is given when registering the application with Google Developer portal.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Google Authorization flow will authorize the user and then return the authentication code to the /oauth2callback servlet. The callback will then send the code received to the token endpoint of the authorization server along with some information like,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;code&lt;/li&gt;
  &lt;li&gt;client_id&lt;/li&gt;
  &lt;li&gt;client_secret&lt;/li&gt;
  &lt;li&gt;redirect_url&lt;/li&gt;
  &lt;li&gt;grant_type – code : use authentication code mechanism&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The token endpoint will return a token that could be used to access the resources of the user. The web server will then store this token against the SESSIONID of the user in a hash map.&lt;/p&gt;

&lt;p&gt;Now the user is Authorized.&lt;/p&gt;

&lt;p&gt;When the user selects a file and uploads it, it is sent to the server and the server will post this file to the Google Drive API resource server along with the token. The token is included as a header as follows.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Authorization : Bearer {«TOKEN»}&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The Google Drive API will return a status code of 201 to indicate that the resource is created.&lt;/p&gt;</content><author><name></name></author><summary type="html">This article explains how to create an application that can be used to upload files to google drive using OAuth2 authorization framework and Google Drive API.</summary></entry><entry><title type="html">CSRF Implementation</title><link href="http://localhost:4000/csrf/2018/09/24/csrf-implementation.html" rel="alternate" type="text/html" title="CSRF Implementation" /><published>2018-09-24T00:50:05+05:30</published><updated>2018-09-24T00:50:05+05:30</updated><id>http://localhost:4000/csrf/2018/09/24/csrf-implementation</id><content type="html" xml:base="http://localhost:4000/csrf/2018/09/24/csrf-implementation.html">&lt;p&gt;This blog explains two demo applications that were built to demonstrate two strategies in defending against CSRF attacks. The two methods are “Synchronizer Token Pattern” and “Double Submit Cookie Pattern” and the applications can be found at,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;https://github.com/Aaquiff/csrf-synchronizer-token-pattern-example&lt;/li&gt;
  &lt;li&gt;https://github.com/Aaquiff/csrf-double-submit-cookie-example&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can also refer to my &lt;a href=&quot;/csrf/2018/10/10/cross-site-request-forgery.html&quot;&gt;article&lt;/a&gt; where I have discussed about CSRF and it’s prevention mechanisms.&lt;/p&gt;

&lt;p&gt;This application allows the administrator to add users. The steps to add a user are given below with screenshots.&lt;/p&gt;

&lt;p&gt;1.Login To the application using the admin credentials “aaralk/aaralk”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-09-24-csrf-implementation/capture.png&quot; alt=&quot;capture.png&quot; title=&quot;capture.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.Click on the “Add User” option, you will be presented with the form to add a user.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-09-24-csrf-implementation/capture1.png&quot; alt=&quot;capture1.png&quot; title=&quot;capture1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3.Enter the username and password for the new user to be added, if you are logged into the system as the administrator, the user will be added.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-09-24-csrf-implementation/capture2.png&quot; alt=&quot;capture2.png&quot; title=&quot;capture2.png&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;synchronizer-token-pattern&quot;&gt;Synchronizer Token Pattern&lt;/h1&gt;

&lt;p&gt;In this method, the server generates a token for each session id and stores it in a key value store. The next time the form loads, it requests the token from the server to which the server responds with the token value(corresponding to the session id) and the browser embeds the token in the form. When the form is posted with the form data, the token is sent along with the form data since it is embedded inside the form. The server then validates the received token against the token in the server(that maps to the session id) to check they are equal. If so we can confirm that the request has come from the form that we have provided to the user. The diagram below illustrates the flow of communication between the browser and the server during this.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-09-24-csrf-implementation/stp.png&quot; alt=&quot;stp.png&quot; title=&quot;stp.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This can help avoid cross site scripting. However when there are huge number of connections open, the server needs to maintain these tokens and this would be problematic in terms of storage and performance. To avoid the need for the server to store tokens, an alternative pattern called Double Submit Cookie Pattern is used.&lt;/p&gt;

&lt;h1 id=&quot;double-submit-cookie-pattern&quot;&gt;Double Submit Cookie Pattern&lt;/h1&gt;

&lt;p&gt;Double submit cookie pattern is efficient than STP since it does not require the server to store the tokens in the server. How this works is, instead of storing the token in the server, a cookie is set in the browser with the token when the token is sent to the browser. Now the browser has the token embedded in the form as well as in the cookie. When the form is posted, the server retrieves the token value from the cookie and the form data and compares each other. If they match, we know that the request come from the correct form.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2018-09-24-csrf-implementation/dscp.png&quot; alt=&quot;dscp.png&quot; title=&quot;dscp.png&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">This blog explains two demo applications that were built to demonstrate two strategies in defending against CSRF attacks. The two methods are “Synchronizer Token Pattern” and “Double Submit Cookie Pattern” and the applications can be found at,</summary></entry></feed>